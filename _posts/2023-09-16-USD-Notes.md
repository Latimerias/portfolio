---
layout:     post
title:      "USD Notes"
active: notes
date:       2023-08-16
header-img: "gallery/archive/uvl/greenhouse_shot_001.jpg"
tags: []
categories: []
comments: false
---

## Animation

The docs define a value clip as "An individual layer containing time varying data over some interval.", this seems to mean that a value clip is simple a layer with time samples.

A clip set is a group of value clips that can be partitioned like in a video editor. So you could have 2 value clips; a run cycle and a walk cycle. In the clip set you can start the have the animation start with the run cycle, stop halfway through, switch to the walk cycle, then back to the remaining half of the run cycle. You could then have another clipset that does the opposite.

Each Clip Set has a Clip Manifest layer/file that declares all of the time sampled attributes, not their values for the clips in the clip set. This saves the value resolution algorithm from having to look through every value clip in the clip set to find out which values to take into account. 

USD Stitch Clips will generate a Clip Set, where each frame/USD file represents a value clip. This means that the generated file will have a manifest since there is the possibility that the time sampled attributes may change by frame.

The value clip LOP will create a value clip. It takes in a Manifest which can be generated by the usdstitchclips ROP and the clips to use. 

## Crowds

The way Houdini generates crowds for USD is like so: 

Every agent layer becomes its own SkelRoot prim. This means that if you have a default layer of a person, and then a hat layer where they are wearing a hat on top of the default layer. The geometry from the default layer will be written out twice to USD, once in each of the SkelRoot layer definition. 

![Alt text](../../../../posts/img/image.png)
![Alt text](../../../../posts/img/image2.png)

Notice how the SkelAnimation lives outside of the SkelRoot, this allows for the SkelRoot to be instanceable while also having every agent with a custom animation.
For example every agent may have the same rig and basic animation but each animation is different because its deformed to a terrain. Having the SkelAnimation outside of the instanceable SkelRoot may seem like it shouldn't work because it is an instanceable prim, but USD works by inheriting down the namespace/hierarchy of instances. If you look at the image below, the skel:animationSource relationship is stoped on the xform prim, instead of the actual skeleton. The skeleton in the instance will then inherit the relationship from above, this also works for primvars.

![Alt text](../../../../posts/img/image3.png)

Storm in usdview is very efficient, around 3gb memory usage for 700 instanced agents. Even when agents were not instanceable memory usage remained around 3gb in usdview. Playback is interactive. Houdini Storm is slightly slower but still usable, and memory usage is around 3gb for the same scene. HoudiniGL is unusable for UsdSkel, 30gb+ memory and too slow to even consider using. When set to uninstanceable, HoudiniGL uses 30gb of memory and playback is still essentially impossible while Houdini Storm uses 3gb.

Karma XPU in usdview and Houdini both consume the same memory around 9gb, which is to be expected. 